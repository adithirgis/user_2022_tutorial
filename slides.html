<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to Spatial Data Analysis in R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Adithi Upadhya, Meenakshi Kushwaha" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introduction to Spatial Data Analysis in R
## useR! 2022
### Adithi Upadhya, Meenakshi Kushwaha
### ILK Labs
### 20th June 2022

---

class:middle, center

# A very brief intro to Map Projections 

![](img/maps_intro.png)

---
# Map Projections
.left-column[
2-D representation of 3-D earth
]
.right-column[
![](img/proj_1.png)
]
.footnote[https://gistbok.ucgis.org/bok-topics/map-projections]

---
# Coordinate Reference Systems (CRS)
- conic, azimuthal, cylindrical
- insert figure
- project your data based on
  - purpose
  - location
  
## CRS in R  

- need to know if it is porjected
  - which project
- if not, you need to project it
  - use the correct system
- most common projection

---

Quiz
first question about your data set
- What is the projection?
- 
- 
- 
---
background-image: url(img/image-from-rawpixel-id-2466603-jpeg.jpg)
background-size:cover
class: middle, center

# Types of Spatial Data
---
# Shape file
- example

---
# A different kind of data structure
Shapefiles
are different from csvs
.pull-left[
![](img/shp_meme.jpeg)
---
# Raster data
![](img/raster_concept.png)
.footnote[Source: National Ecological Observatory Network (NEON)]

---
# Quiz on vector and raster
---
# Summary of Theory
(mental map)
---

class:middle, center

# sf

![](img/sf.jpeg)

---

# [sf package](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)


Package `sf` represents simple features as native R objects. 
Similar to PostGIS, all functions and methods in sf that operate on spatial data are prefixed by st_. 

Simple features are implemented as R native data, using simple data structures (S3 classes, lists, matrix, vector).

Typical use involves reading, manipulating and writing of sets of features, with attributes and geometries.


&lt;span role="img" aria-label="Three cute fuzzy monsters adding spatial geometries to an existing table of attributes using glue and tape, while one cuts out the spatial polygons. Title text reads âsf: spatial data...simplified.â and a caption at the bottom reads âsticky geometries: for people who love their maps and sanity."&gt;&lt;/span&gt;

???

Use the sf package for simpler spatial data analysis with geometries that stick to attributes. As attributes are typically stored in `data.frame` objects (or the very similar `tbl_df`), we will also store feature geometries in a `data.frame` column. Since geometries are not single-valued, they are put in a `list-column`, a list of length equal to the number of records in the `data.frame`, with each list element holding the simple feature geometry of that feature. The three classes used to represent simple features are:

`sf`, the table (data.frame) with feature attributes and feature geometries, which contains
`sfc`, the list-column with the geometries for each feature (record), which is composed of
`sfg`, the feature geometry of an individual simple feature.


---

# Geometry types

`POINT`: a single point

`MULTIPOINT`: multiple points

`LINESTRING`: sequence of two or more points connected by straight lines

`MULTILINESTRING`: multiple lines

`POLYGON`: a closed ring with zero or more interior holes

`MULTIPOLYGON`: multiple polygons

`GEOMETRYCOLLECTION`: any combination of the above types


---

# Advantages of `sf`

Is treated as a `data.frame` 

Can be used with a pipe operator

Can be linked directly to the `GDAL`, `GEOS`, and `PROJ` libraries that provide the back end for reading spatial data, making geographic calculations, and handling coordinate reference systems

---

# Load the libraries 


```r
library(sf)
library(raster)
library(stars)
library(leaflet)
library(ggplot2)
library(ggspatial)
```


---


# `st_as_sf`

Convert foreign object to an `sf` object.



```r
data &lt;- read.csv("data/spotted.csv", sep = ",")
prj4string &lt;- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
my_projection &lt;- st_crs(prj4string)

# Create sf object
data_sf &lt;- st_as_sf(data, coords = c("Longitude", "Latitude"), crs = my_projection)
```


---

class:middle, center

# Demo

---

# Interactive Map



```r
leaflet(data) %&gt;%
      addTiles() %&gt;%
      addCircles(
        data = data,
        lng = ~ Longitude,
        lat = ~ Latitude,
        radius = 20,
        weight = 20,
        fill = TRUE) 
```


---

class:middle, center

# Demo

---

# `st_is_valid`

Checks whether a geometry is valid, or makes an invalid geometry valid.


```r
st_is_valid(data_sf)
```


---

# `st_write` and  `st_read`

Write simple features object to file or database.

Read a simple features object.


```r
st_write(data_sf, "data/spotted_sf.shp")
# To save the XY or the coordinates use layer_options
st_write(data_sf, "data/spotted_sf.shp", layer_options = "GEOMETRY=AS_XY")

data_sf &lt;- st_read("data/spotted_sf.shp")
```

---

# `st_point`

Create simple feature from a numeric vector, matrix or list.


```r
p1 &lt;- st_point(c(2, 3))
p2 &lt;- st_point(c(1, 4))

class(p1) 
```

---

# Geometry types

`st_point`	numeric vector (or one-row matrix)

`st_multipoint`	numeric matrix with points in row

`st_linestring`	numeric matrix with points in row

`st_multilinestring`	list with numeric matrices with points in rows

`st_polygon`	list with numeric matrices with points in rows

`st_multipolygon`	list of lists with numeric matrices

`st_geometrycollection`	list with (non-geometrycollection) simple feature objects

---


# `st_crs` and `st_geometry_type`

Retrieve coordinate reference system from `sf` object.

Set or replace retrieve coordinate reference system from object.


```r
st_crs(data_sf)
st_geometry_type(data_sf)
```

---

# `st_transform`

Transform or convert coordinates of simple feature.


```r
data_sf_projected &lt;- st_transform(data_sf, 32643)
```


---

class:middle, center

# Demo

---
class: inverse, center, middle
background-image: url(https://www.valueresearchonline.com/content-assets/images/48497_measuring-the-world_02__w660__.gif)
background-size: contain

# Geometric measurements



---

# `st_distance`

Compute Euclidian or great circle distance between pairs of geometries; compute, the area or the length of a set of geometries. 

If the coordinate reference system of x was set, these functions return values with unit of measurement.


```r
st_distance(data_sf_projected[c(1), ], data_sf_projected[c(2), ])
```

---

class: inverse, center, middle
background-image: url(https://cdn.dribbble.com/users/1002383/screenshots/4252960/v13.gif)
background-size: contain

# Geometric unary operations


---

# `st_buffer`

Computes a buffer around this geometry/each geometry.

Returns a new geometry.


```r
buf &lt;- st_buffer(data_sf_projected, dist = 3000)
```


---

class:middle, center

# Demo


---

# `st_area`

Returns the area of a geometry, in the coordinate reference system used; in case x is in degrees longitude/latitude, `st_geod_area` is used for area calculation.


---

class:middle, center

# Demo


---

# More 

`st_boundary` returns the boundary of a geometry

`st_convexhull` creates the convex hull of a set of points

`st_reverse` reverses the nodes in a line

`st_simplify` simplifies lines by removing vertices

`st_triangulate` triangulates set of points (not constrained)

`st_polygonize` creates polygon from lines that form a closed ring. In case of `st_polygonize`, x must be an object of class `LINESTRING` or `MULTILINESTRING`, or an sfc geometry list-column object containing these

`st_centroid` gives the centroid of a geometry

`st_segmentize` adds points to straight lines

`st_union` combines several feature geometries into one, without unioning or resolving internal boundaries

---

class: inverse, center, middle
background-image: url(https://datavisdotblog.files.wordpress.com/2020/02/intersects-join-nx-30fps-33ms.gif)
background-size: contain

# Geometric binary predicates

---

# `st_intersects`

To find whether pairs of simple feature geometries intersect.

Returns `TRUE` or `FALSE.`


```r
st_intersects(data_sf_projected[1, ], data_sf_projected[2, ])
```


---

class:middle, center

# Demo

---

# [More](http://postgis.net/workshops/postgis-intro/spatial_relationships.html) 

Geometric binary predicates on pairs of simple feature geometry sets.
Return a sparse matrix with matching (`TRUE`) indexes, or a full logical matrix.

`st_intersects` test whether Geometries/Geography spatially intersect

`st_disjoint` returns `TRUE` if the Geometries do not spatially intersect - if they do not share any space together

`st_touches` returns `TRUE` if the geometries have at least one point in common, but their interiors do not intersect

`st_crosses` returns `TRUE` if the supplied geometries have some, but not all, interior points in common

`st_within` returns TRUE if the first geometry is completely within the second geometry 

`st_contains` returns `TRUE` if the second geometry is completely contained by the first geometry

`st_overlaps` returns `TRUE` if the Geometries share space, are of the same dimension, but are not completely contained by each other

`st_equals` returns true if the given geometries represent the same geometry. Directionality is ignored

`st_is_within_distance` returns `TRUE` if the geometries are within the specified distance (radius) of one another


---

# Other operations 

---

# `st_join` 


```r
a &lt;- st_sf(a = 1:3,
 geom = st_sfc(st_point(c(1, 1)), st_point(c(2, 2)), st_point(c(3, 3))))
b &lt;- st_sf(b = 11:14,
 geom = st_sfc(st_point(c(10, 10)), st_point(c(2, 2)), st_point(c(2, 2)), st_point(c(3, 3))))
c &lt;- st_join(a, b, join = st_nearest_feature)
```


---

class:middle, center

# Demo


---

class:middle, center

![](img/sf_concept_map.png)


---

class:middle, center

# raster



---



# Raster 

A `RasterLayer` can easily be created from scratch using the function raster. 
The default settings will create a global raster data structure with a longitude/latitude coordinate reference system and 1 by 1 degree cells. 
You can change these settings by providing additional arguments such as `xmn`, `nrow`, `ncol`, `res`, and/or `crs`, to the function. You can also change these parameters after creating the object. 


```r
temp &lt;- raster("data/Ban_Temp_Mar2022.tif")
temp

y &lt;- raster(ncol = 36, nrow = 18, xmn = -1000, xmx = 1000, ymn = -100, ymx = 900)
y
```

---

class:middle, center

# Demo

---

# Summary and Resolution


```r
res(temp)
summary(temp)

res(y)
summary(y)
```

---

# `projectRaster`

To transform a `RasterLayer` to another coordinate reference system (projection)


```r
# To transform 
temp_proj &lt;- projectRaster(temp, crs = "+proj=utm +zone=48 +datum=WGS84", method = "ngb")

# To set the coordinate system 
projection(y) &lt;- "+proj=utm +zone=48 +datum=WGS84"
y
# To transform
y_prof &lt;- projectRaster(y, crs = "+proj=longlat +datum=WGS84 +no_defs", method = "ngb")
```


---

class:middle, center

# Demo

---

# Summarizing functions

Use `cellStats` to obtain a summary for all cells of a single Raster object. 


```r
cellStats(temp, mean)
```

---

# Raster algebra 

When used with a Raster object as first argument, normal summary statistics functions such as `min`, `max`, and `mean` return a `RasterLayer` (usually for multiple layers). 


```r
r1 &lt;- temp
r2 &lt;- r1

s &lt;- stack(r1, r2)
plot(max(s, na.rm = TRUE))
```


---

# Extract

Extract values from a `Raster` object at the locations of spatial vector data


```r
extract(temp, data_sf)
```

---

# Mask by buffer 

Mask values from a `Raster` object at the locations of spatial vector data


```r
data_sf_subset &lt;- data_sf[1, ]

data_sf_buffer &lt;- st_buffer(data_sf_subset, dist = 5000) 
masked_raster &lt;- mask(x = temp, mask = data_sf_buffer)
```

---

class:middle, center

# Demo

---

# Raster operation 

Returns a geographic subset of an object as specified by an Extent object (or object from which an extent object can be extracted/created) 

---

# Calculate area

- Computes the approximate surface area of cells in an unprojected (longitude/latitude) `Raster` object
- returns all values or the values for a number of rows of a `Raster` object. Values returned for a `RasterLayer` are a vector


```r
sum(getValues(area(temp_proj)))
```


---

class:middle, center


![](img/raster_concept_map.png)


---


# Rasterize using `stars`


```r
raster_data &lt;- st_rasterize(data_sf)
```

---

# Vectorize using `stars` 
 

```r
tif &lt;- read_stars("data/Ban_Temp_Mar2022.tif")
summary(tif)
class(tif)
# Convert a foreign object to sf
temp_sf &lt;- st_as_sf(tif, as_points = TRUE, merge = FALSE)
```

---

class:middle, center

# Demo

---


# Static Map 


```r
bangalore_boundary &lt;- st_read("data/BBMP_Boundary.shp")
bangalore_boundary &lt;- st_transform(bangalore_boundary, crs = my_projection)

ggplot() + geom_sf(data = bangalore_boundary, color = "green", size = 2, alpha = 0.1, fill = "green") +
  geom_sf(data = data_sf, color = "blue", size = 2) + theme_bw() +
  annotation_scale(location = "bl", width_hint = 0.5) +
  annotation_north_arrow(location = "bl", which_north = "true", 
                         pad_x = unit(0.75, "in"), pad_y = unit(0.5, "in"),
                         style = north_arrow_fancy_orienteering) +
  coord_sf(xlim = c(77.4, 77.8), ylim = c(12.8, 13.2))
```

---

class:middle, center

# Demo

---


# Interactive Map


```r
leaflet(bangalore_boundary) %&gt;% 
  addTiles() %&gt;% 
  addPolygons(color = "green") %&gt;%
      addCircles(
        data = data,
        lng = ~ Longitude,
        lat = ~ Latitude,
        radius = 20,
        weight = 20,
        fill = TRUE)
```

---

class:middle, center

# Demo

---

# Data Sources 

- [NaturalEarth](https://www.naturalearthdata.com/) supported by [`rnaturalearth`](https://cran.r-project.org/web/packages/rnaturalearth/README.html)
- [OpenStreetMaps](https://www.openstreetmap.org/) supported by [`osmdata`](https://cran.r-project.org/web/packages/osmdata/index.html).
- [ETOPO5](https://www.ngdc.noaa.gov/mgg/global/etopo5.HTML) elevation data. 
- [Movebank](https://www.movebank.org/cms/movebank-main) animal movement data.
- [EuroStat](https://ec.europa.eu/eurostat) provides European Statistics and Indicators.
- [Global Human Settlement Layer](https://ghsl.jrc.ec.europa.eu/) provides population data and other similar datasets. 
- [USGS Global Island Explorer](https://rmgsc.cr.usgs.gov/gie/) island datasets. 
- [spData](https://cran.r-project.org/web/packages/spData/spData.pdf) diverse spatial datasets for demonstrating and teaching spatial data analysis. 


---

# Resources used

https://bookdown.org/nicohahn/making_maps_with_r5/docs/ggplot2.html#using-ggplot2-to-create-maps
https://www.youtube.com/watch?v=qbrnzSRPyb0 
https://geocompr.robinlovelace.net/spatial-class.html
https://github.com/statnmap/user2020_rspatial_tutorial
https://www.jessesadler.com/post/simple-feature-objects/
https://heima.hafro.is/~einarhj/spatialr/pre_sf.html
https://cran.r-project.org/web/packages/sf/vignettes/sf1.html
https://mgimond.github.io/Spatial/raster-operations-in-r.html#computing-cumulative-distances
https://r-spatial.github.io/stars/
Images from [rawpixel](https://www.rawpixel.com/)

---

# THANK YOU 


- [Adithi R Upadhya](https://adithirugis.rbind.io/)
- [Meenakshi Kushwaha](https://meenakshi.rbind.io/) 
- [Pratyush Agrawal](https://twitter.com/Pratyushagraw97) 

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
